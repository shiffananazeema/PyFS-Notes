Python: 
```````
 	- Popular Programming Language - Guido van Rossum in 1991 at CWI in the Netherlands
	- Python is an interpreted, high-level, general-purpose programming language.
	- It is designed to be easy to read and write, with a focus on code readability and simplicity.	
	- Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming.

1. Reserved words or Keywords:
2. Variable:
3. Data Types:
4. Operations:
5. Operators:
6. Flow Control:
7. Collection Data Types:
8. Functions:
9. Object Oriented Programming:

[Qucik Search: Select -> Contol + f -> Enter]

1. Reserved words or Keywords:
```````````````````````````````

	- Keywords have special meanings to the compiler. There are 37 keywords.
	- They cannot be used as identifiers (variable names, function names, etc.)
	- Keywords are case-sensitive, meaning that they must be written in lowercase.

	False		await		else		import		pass		match
	None		break	   	except		in			raise 		case
	True		class	   	finally		is			return
	and 		continue   	for			lambda		try
	as 			def 	   	from		nonlocal	while
	assert		del   	   	global		not			with
	async		elif	   	if			or			yield

	Value Keywords				- 	True, False, None
	Operator Keywords			- 	and, or, not, in, is
	Control Flow Keywords		- 	if, elif, else, match, case
	Iteration Keywords			- 	for, while, break, continue, pass
	Structure Keywords			- 	def, class, with, lambda
	Returning Keywords			-	return, yield
	Import Keywords				- 	import, from, as
	Exception-Handling Keywords -	try, except, raise, finally, assert
	Asynchronous Keywords	  	- 	async, await
	Variable Handling Keywords  - 	del, global, nonlocal


	True, False - Boolean value
	Eg:
		x = True			y = False
		x is True			y is not True
		# True			# True
		
	None - Represents no Value
	Eg:
		def func():				- can't print the call 
			print("hello")			- can't print the print
		x = func()
		# hello
		print(x)			
		# None
    
2. Variable:
````````````
	Cotainers for storing data values. 
	Literals - Raw data assigned to a Variable or Constant
	Python is a dynamically-typed language, and there is no built-in mechanism to enforce constant values.
	Variable naming rules (e.g., no starting with numbers, no special characters except _).	
		- Python is case sensitive. Eg: y and Y are Different

	name  = "Shiffana" 
	|	      |
	Variable   Literal

3. Data Types:
``````````````
	- Data types are classifications of data that determine the kind of value a variable can hold and the operations that can be performed on it.
	- Python is a dynamically typed language, meaning you don't need to declare the data type of a variable explicitly.
	- In Python, there are several built-in data types that you can use to store different kinds of data. 
		Here is a comprehensive list of all the data types in Python:

	|   Category         |   Type       |   Description                                     |   Example                           |
	| ------------------ | ------------ | ------------------------------------------------- | ----------------------------------- |
	| 1 Numeric Types    |  int         | Whole numbers, positive or negative               |  x = 10                             |
	|                    |  float       | Numbers with decimal points                       |  pi = 3.14                          |
	|                    |  complex     | Numbers with real and imaginary parts             |  z = 2 + 3j                         |
	| 2 Text Type        |  str         | Sequence of characters (Unicode)                  |  name = "Alice"                     |
	| 3 Boolean Type     |  bool        | Logical values: True or False                     |  is_active = True                   |
	| 4 Sequence Types   |  list        | Mutable ordered sequence                          |  fruits = ["apple", "banana"]       |
	|                    |  tuple       | Immutable ordered sequence                        |  point = (10, 20)                   |
	|                    |  range       | Immutable range of numbers                        |  numbers = range(5)                 |
	| 5 Mapping Type     |  dict        | Key-value pair collection                         |  user = {"name": "Bob", "age": 30}  |
	| 6 Set Types        |  set         | Unordered collection of unique elements (mutable) |  s = {1, 2, 3}                      |
	|                    |  frozenset   | Unordered unique collection (immutable)           |  fs = frozenset([1, 2, 3])          |
	| 7 Binary Types     |  bytes       | Immutable byte sequence                           |  b = b"hello"                       |
	|                    |  bytearray   | Mutable byte sequence                             |  ba = bytearray(b"data")            |
	|                    |  memoryview  | View over byte data                               |  mv = memoryview(b"abc")            |
	| 8 None Type        |  NoneType    | Represents absence of value                       |  result = None ; type(None)         |


	Data Type:			Type Casting:	- Changing the type of data
	``````````			`````````````
	print(type(x))		x = int("3")		

4. Operations: 
``````````````
	- Operations are actions performed on data types using operators or methods.
	- They allow you to manipulate, compare, and transform data.
	- Tuples and dictionaries support indexing and key-based access

	1. String Operations 

		|   Operation      |   Description                                  |   Example                          |
		| ---------------- | ---------------------------------------------- | ---------------------------------- |
		|  ' '  /  " "     | Define a string                                |  'Hello' ,  "World"                |
		|  len()           | Length of the string                           |  len("Python") ‚Üí 6                 |
		|  in ,  not in    | Check if a substring exists                    |  "a" in "cat" ‚Üí True               |
		| Indexing         | Access character by position                   |  "Hello"[1] ‚Üí 'e'                  |
		| Slicing          | Access part of the string                      |  "Hello"[1:4] ‚Üí 'ell'              |
		|  upper()         | Convert to uppercase                           |  "hi".upper() ‚Üí "HI"               |
		|  lower()         | Convert to lowercase                           |  "HI".lower() ‚Üí "hi"               |
		|  capitalize()    | Capitalize first character                     |  "python".capitalize() ‚Üí "Python"  |
		|  strip()         | Remove whitespace from both ends               |  "  hi  ".strip() ‚Üí "hi"           |
		|  replace()       | Replace parts of a string                      |  "hi".replace("h", "H") ‚Üí "Hi"     |
		|  split()         | Split into list by delimiter                   |  "a,b".split(",") ‚Üí ['a', 'b']     |
		|  format()        | Format strings with placeholders  {}           |  "Hello {}".format("World")        |
		|  find()          | Find first occurrence of substring             |  "apple".find("p") ‚Üí 1             |
		|  rfind()         | Find last occurrence of substring              |  "banana".rfind("a") ‚Üí 5           |
		|  index()         | Like  find()  but raises error if not found    |  "abc".index("b") ‚Üí 1              |
		|  startswith()    | Check if string starts with value              |  "apple".startswith("a") ‚Üí True    |
		|  endswith()      | Check if string ends with value                |  "apple".endswith("e") ‚Üí True      |
		|  isalpha()       | Check if all characters are letters            |  "abc".isalpha() ‚Üí True            |
		|  isdigit()       | Check if all characters are digits             |  "123".isdigit() ‚Üí True            |
		|  isalnum()       | Check if all characters are alphanumeric       |  "abc123".isalnum() ‚Üí True         |
		|  isupper()       | Check if all characters are uppercase          |  "HELLO".isupper() ‚Üí True          |
		|  islower()       | Check if all characters are lowercase          |  "hello".islower() ‚Üí True          |
		|  join()          | Join iterable into string                      |  ",".join(["a", "b"]) ‚Üí "a,b"      |
		|  zfill()         | Pad string on the left with zeros              |  "7".zfill(3) ‚Üí "007"              |
		| Escape Sequences | Special characters: newline, tab, quotes, etc. |  \n ,  \t ,  \' ,  \\ ,  \"        |

	2. List Operations

		|   Operation          |   Description                                     |   Example                             |
		| -------------------- | ------------------------------------------------- | ------------------------------------- |
		|  len()               | Get number of items in the list                   |  len([1, 2, 3]) ‚Üí 3                   |
		|  in ,  not in        | Check if item exists in the list                  |  "apple" in fruits ‚Üí True             |
		| Indexing             | Access item by index                              |  fruits[0] ‚Üí "apple"                  |
		| Slicing              | Get sublist by range                              |  fruits[1:3] ‚Üí ['banana', 'mango']    |
		|  count()             | Count occurrences of an item                      |  fruits.count("apple") ‚Üí 2            |
		|  index()             | Find index of the first matching item             |  fruits.index("banana") ‚Üí 1           |
		| Change Item          | Modify item by index                              |  fruits[1] = "grape"                  |
		|  insert()            | Insert item at a specific index                   |  fruits.insert(2, "melon")            |
		|  append()            | Add item to the end of the list                   |  fruits.append("kiwi")                |
		|  extend()            | Add multiple items from another list              |  fruits.extend(["peach", "plum"])     |
		|  remove()            | Remove first occurrence of an item                |  fruits.remove("apple")               |
		|  pop()               | Remove item at index or last if no index provided |  fruits.pop(1) ,  fruits.pop()        |
		|  del                 | Delete item by index or entire list               |  del fruits[1] ,  del fruits          |
		|  clear()             | Remove all items from the list                    |  fruits.clear()                       |
		|  sort()              | Sort list in ascending order                      |  fruits.sort()                        |
		|  sort(reverse=True)  | Sort list in descending order                     |  fruits.sort(reverse=True)            |
		|  reverse()           | Reverse the list order                            |  fruits.reverse()                     |
		|  copy()              | Create a shallow copy of the list                 |  new_list = fruits.copy()             |
		| List Comprehension   | Create list using loop and condition              |  [x for x in range(5) if x % 2 == 0]  |

	3. Set Operations

		|   Operation              |   Description                                  |   Example                     |
		| ------------------------ | ---------------------------------------------- | ----------------------------- |
		|  add()                   | Adds an element to the set                     |  s.add(5)                     |
		|  update()                | Adds multiple elements                         |  s.update([1, 2, 3])          |
		|  remove()                | Removes element; error if not found            |  s.remove(2)                  |
		|  discard()               | Removes element if present; no error if absent |  s.discard(10)                |
		|  pop()                   | Removes a random element                       |  s.pop()                      |
		|  clear()                 | Removes all elements                           |  s.clear()                    |
		|  union()                 | Returns union of two sets                      |  s1.union(s2)                 |
		|  intersection()          | Returns common elements                        |  s1.intersection(s2)          |
		|  difference()            | Returns items only in first set                |  s1.difference(s2)            |
		|  symmetric_difference()  | Items in either, but not both sets             |  s1.symmetric_difference(s2)  |
		|  issubset()              | Checks if set is subset                        |  s1.issubset(s2)              |
		|  issuperset()            | Checks if set is superset                      |  s1.issuperset(s2)            |
		|  isdisjoint()            | Checks if sets have no items in common         |  s1.isdisjoint(s2)            |

	4. Tuple Operations 

		|   Operation   |   Description                          |   Example                 |
		| ------------- | -------------------------------------- | ------------------------- |
		| Indexing      | Access item by index                   |  t[1] ‚Üí 'banana'          |
		| Slicing       | Access a range of items                |  t[1:3]                   |
		|  count()      | Count occurrences of a value           |  t.count("apple") ‚Üí 2     |
		|  index()      | Find index of a value                  |  t.index("banana") ‚Üí 1    |
		|  in           | Check if value exists                  |  "apple" in t ‚Üí True      |
		|  len()        | Length of tuple                        |  len(t) ‚Üí 3               |
		| Immutability  | Cannot be modified after creation      |  t[0] = "new"  ‚ùå Error   |
		| Nesting       | Tuples can contain lists, other tuples |  t = (1, [2, 3], (4, 5))  |

	5. Dictionary Operations
		|   Operation   |   Description                                     |   Example                |
		| ------------- | ------------------------------------------------- | ------------------------ |
		|  get()        | Gets value by key (returns None if not found)     |  d.get("name")           |
		|  keys()       | Returns list-like view of all keys                |  d.keys()                |
		|  values()     | Returns list-like view of all values              |  d.values()              |
		|  items()      | Returns view of key-value pairs                   |  d.items()               |
		|  update()     | Updates dictionary with another dict or key-value |  d.update({"age": 30})   |
		|  pop()        | Removes key and returns its value                 |  d.pop("name")           |
		|  popitem()    | Removes and returns last key-value pair           |  d.popitem()             |
		|  del          | Deletes key or entire dict                        |  del d["name"] ,  del d  |
		|  clear()      | Empties the dictionary                            |  d.clear()               |
		|  in           | Check if key exists                               |  "name" in d ‚Üí True      |
		| Indexing      | Access or assign value with key                   |  d["name"] = "Ali"       |

	6. File Operations

	|   Operation    |   Description                                            |   Example                      |
	| -------------- | -------------------------------------------------------- | ------------------------------ |
	|  open()        | Opens a file ( 'r' ,  'w' ,  'a' ,  'rb' ,  'wb' , etc.) |  f = open("file.txt", "r")     |
	|  read()        | Reads entire file content                                |  f.read()                      |
	|  readline()    | Reads one line                                           |  f.readline()                  |
	|  readlines()   | Reads all lines into a list                              |  f.readlines()                 |
	|  write()       | Writes content (overwrites in  'w'  mode)                |  f.write("Hello")              |
	|  writelines()  | Writes a list of strings to a file                       |  f.writelines(["a\n", "b\n"])  |
	|  close()       | Closes the file                                          |  f.close()                     |
	|  with open()   | Context manager to open file (auto-close)                |  with open("file.txt") as f:   |
	|  seek()        | Move the file cursor to given position                   |  f.seek(0)                     |
	|  tell()        | Returns current file position                            |  f.tell()                      |
	|  flush()       | Force write buffer to disk                               |  f.flush()                     |

5. Operators:
``````````````
	- Operators are symbols that perform operations on variables and values.
	- They are used to manipulate data and variables in Python.
	- Operators can be classified into several categories based on their functionality.

	1. Arithmetic Operator	
			- Numeric values to perform common Mathematical Operations
				
				+ , - , * , / , % , ** , // 

		| Operator | Name           | Description                               | Example        |
		| -------- | -------------- | ----------------------------------------- | -------------- |
		|  +       | Addition       | Adds two values                           | 3 + 2 = 5     |
		|  -       | Subtraction    | Subtracts right operand from left         |  5 - 2 = 3     |
		|  *       | Multiplication | Multiplies both values                    |  4 * 3 = 12    |
		|  /       | Division       | Divides left by right (float result)      |  10 / 4 = 2.5  |
		|  //      | Floor Division | Divides and removes decimal (rounds down) |  10 // 4 = 2   |
		|  %       | Modulo         | Returns remainder                         |  10 % 3 = 1    |
		|  **      | Exponentiation | Power of (left raised to right)           |  2 ** 3 = 8    |
				
	2. Assignment Operator	
			- Assign values to Variables 
				
				= , += , -=, *= , /=, %=, **=, //= , &= , |= , ^= , >>= , <<= 

		| Operator | Name                | Description       | Example   |   
		| -------- | ------------------- | ----------------- | --------- | 
		|  =       | Assignment          | Assigns value     |  x = 5    |     
		|  +=      | Add AND assign      |  x = x + 3        |  x += 3   |    
		|  -=      | Subtract AND assign |  x = x - 2        |  x -= 2   |     
		|  *=      | Multiply AND assign |  x = x * 4        |  x *= 4   |   
		|  /=      | Divide AND assign   |  x = x / 2        |  x /= 2   |  
		|  //=     | Floor divide assign |  x = x // 2       |  x //= 2  |  
		|  %=      | Modulo AND assign   |  x = x % 2        |  x %= 2   |   
		|  **=     | Power AND assign    |  x = x ** 2       |  x **= 2  |    
		|  &=      | Bitwise AND assign  |  x = x & 1        |  x &= 1   |   
		|  |=      | Bitwise OR assign   |  x = x | 2        |  x |= 2   | 
		|  ^=      | Bitwise XOR assign  |  x = x ^ 3        |  x ^= 3   |     
		|  >>=     | Right shift assign  |  x = x >> 1       |  x >>= 1  |    
		|  <<=     | Left shift assign   |  x = x << 1       |  x <<= 1  |    
	
	3. Comparison Operator	
			- Compare two values
				
				== , != , > , < , >= , <=

		| Operator | Description              | Example  |
		| -------- | ------------------------ | -------- |
		|  ==      | Equal to                 |  x == y  |
		|  !=      | Not equal to             |  x != y  |
		|  >       | Greater than             |  x > y   |
		|  <       | Less than                |  x < y   |
		|  >=      | Greater than or equal to |  x >= y  |
		|  <=      | Less than or equal to    |  x <= y  |
				
	4. Logical Operator	
			- Combine Conditional Statements
				
				and , or , not 

		| Operator | Description                      | Example            |
		| -------- | -------------------------------- | ------------------ |
		|  and     | True if both conditions are True |  x > 2 and x < 10  |
		|  or      | True if one condition is True    |  x < 5 or x > 20   |
		|  not     | Reverses the condition           |  not(x == 5)       |
				
	5. Identity Operator	
			- Compare the objects
				
				is , is not

		| Operator | Description                                 | Example      |
		| -------- | ------------------------------------------- | ------------ |
		|  is      | True if both variables point to same object |  x is y      |
		|  is not  | True if they don't point to same object     |  x is not y  |
				
	6. Membership Operator	
			- Test is a sequence is present
				
				in , not in

		| Operator | Description                   | Example            |
		| -------- | ----------------------------- | ------------------ |
		|  in      | True if value is in sequence  |  "a" in "apple"    |
		|  not in  | True if value not in sequence |  "z" not in "dog"  |

	7. Bitwise Operator	
 		- Compare Binary Numbers
 			
			 & , | , ^ , ~ , << , >>
			
		| Operator | Description        | Example (in binary)       |     
		| -------- | ------------------ | ------------------------- |
		|  &       | AND                |  5 & 3 ‚Üí 101 & 011 = 001  |    
		|  |       | OR                 |  5 | 3 ‚Üí 101 | 011 = 111  |                    
		|  ^       | XOR (exclusive OR) |  5 ^ 3 ‚Üí 101 ^ 011 = 110  |   
		|  ~       | NOT (inverts bits) |  ~5 ‚Üí -(5+1) = -6         |  
		|  <<      | Left shift         |  2 << 1 ‚Üí 4  (10 ‚Üí 100)   |    
		|  >>      | Right shift        |  4 >> 1 ‚Üí 2  (100 ‚Üí 10)   |    

6. Flow Control:
`````````````````
	- Flow control statements determine the order in which statements are executed in a program.
	- They allow you to control the flow of execution based on conditions, loops, and exceptions.
	- Flow control statements are essential for making decisions, repeating actions, and handling errors in your code.

	1. Conditional Statement
			- It lets the program decide which block of code to execute based on the condition. Decision making.

		|  Name      |  Definition                                          |  Syntax                 |  Example                            |
		| ---------- | ---------------------------------------------------- | ----------------------- | ----------------------------------- |
		|  if        | Runs a block of code if the condition is True        |  if condition:          |  if x > 10:\n    print("Big")       |
		|  elif      | Runs if the  if  is False and this condition is True |  elif condition:        |  elif x == 10:\n    print("Equal")  |
		|  else      | Runs if all above conditions are False               |  else:                  |  else:\n    print("Small")          |
		| Ternary if | One-line conditional expression                      |  x if condition else y  |  result = "Yes" if x > 0 else "No"  |

	2. Looping Statement
			- Used to repeate a block of code multiple times.

		|  Name    |  Definition                              |  Syntax                |  Example                           |
		| -------- | ---------------------------------------- | ---------------------- | ---------------------------------- |
		|  for     | Iterates over items in a sequence        |  for var in sequence:  |  for i in range(3):\n    print(i)  |
		|  while   | Repeats code while the condition is True |  while condition:      |  while x < 5:\n    x += 1          |

	3. Loop Control Statement
			- Used to alter the flow of loops: exit early, skip iterations or do nothing.

		|  Name          |  Definition                                       |  Syntax               |  Example                                     |
		| -------------- | ------------------------------------------------- | --------------------- | -------------------------------------------- |
		|  break         | Exits the loop immediately                        |  break                |  if x == 3:\n    break                       |
		|  continue      | Skips the rest of the loop iteration              |  continue             |  if x % 2 == 0:\n    continue                |
		|  pass          | Does nothing (placeholder)                        |  pass                 |  if True:\n    pass                          |
		|  else  on loop | Executes if the loop was not exited using  break  |  for/while ... else:  |  for i in range(3): ... else: print("Done")  |

	4. Exception Handling Statement
			- Used to handle errors or unexpected conditions gracefully without crashing the program

		|  Name     |  Definition                              |  Syntax             |  Example                                        |
		| --------- | ---------------------------------------- | ------------------- | ----------------------------------------------- |
		|  try      | Block where an error might occur         |  try:               |  try:\n    x = 1 / 0                            |
		|  except   | Block to handle the error                |  except ErrorType:  |  except ZeroDivisionError:\n    print("Error")  |
		|  else     | Runs if  try  succeeds without exception |  else:              |  else:\n    print("No errors")                  |
		|  finally  | Runs no matter what, error or no error   |  finally:           |  finally:\n    print("Cleanup")                 |

	5. Match Statement
			- Pattern matching allows matching values and executing corresponding code blocks, similar to switch in other languages.

		|  Name    |  Definition                               |  Syntax           |  Example                        |
		| -------- | ----------------------------------------- | ----------------- | ------------------------------- |
		|  match   | Start of the pattern matching structure   |  match variable:  |  match status:                  |
		|  case    | Handles each pattern                      |  case value:      |  case 200:\n    print("OK")     |
		|  case _  | Catch-all case (like  default  in switch) |  case _:          |  case _:\n    print("Unknown")  |

	6. Assert Statement
		- Used to debugging. It tests if a condition is True; if not, it raises an AssertionError.

	|  Name    |  Definition                  |  Syntax            |  Example                             |
	| -------- | ---------------------------- | ------------------ | ------------------------------------ |
	|  assert  | Tests if a condition is True |  assert condition  |  assert x > 0, "x must be positive"  |
		
7. Collection Data Types:
``````````````````````````
	- Collection data types are used to store multiple items in a single variable.
	- They allow you to group related data together and perform operations on the entire collection.	
	- Python has several built-in collection data types, each with its own characteristics and use cases.


	| Type          | Ordered | Mutable | Allows Duplicates | Unique Feature                     | Example                        |
	| ------------- | ------- | ------- | ----------------- | ---------------------------------- | ------------------------------ |
	|   List        |   Yes   |   Yes   |   Yes             | Ideal for ordered, changeable data | `["a", "b", "c"]`              |
	|   Tuple       |   Yes   |   No    |   Yes             | Immutable list                     | `("a", "b", "c")`              |
	|   Set         |   No    |   Yes   |   No              | Only unique items                  | `{"a", "b", "c"}`              |
	|   Frozenset   |   No    |   No    |   No              | Immutable version of set           | `frozenset(["a", "b", "c"])`   |
	|   Dict        |   Yes   |   Yes   |   (Keys)          | Key-value pairs                    | `{"name": "Alice", "age": 25}` |

	1. List ‚Äì Use when you need a dynamic and ordered collection (e.g., shopping list).
	2. Tuple ‚Äì Use when the data should not change (e.g., GPS coordinates).
	3. Set ‚Äì Use when you want to store unique values (e.g., removing duplicates).
	4. Dictionary ‚Äì Use when you want to map keys to values (e.g., storing employee data).
	5. frozenset ‚Äì Use when you want a constant set (e.g., as a dictionary key or for hashable needs).

8. Functions:
`````````````
	- Functions are reusable blocks of code that perform a specific task.
	- They help organize code, avoid repetition, and make it easier to read and maintain.	
	- Functions can take inputs (parameters) and return outputs (return values).

	Concept	Explanation	Example
	Function Definition	Define a function using def keyword	def greet():
		print('Hello')
	Function Call	Execute a function	greet()
	Parameters	Variables in function definition	def greet(name):
		print('Hello', name)
	Arguments	Values passed to a function	greet('Shiffana')
	Return Statement	Return a value to the caller	def add(a, b):
		return a + b
	Default Parameters	Parameter with default value	def greet(name='Guest'):
		print('Hello', name)
	Keyword Arguments	Pass values using parameter names	def student(name, age):
		print(name, age)
	student(age=20, name='Ali')
	*args	Accept multiple positional arguments	def show(*args):
		for i in args:
			print(i)
	**kwargs	Accept multiple keyword arguments	def show(**kwargs):
		for k, v in kwargs.items():
			print(k, v)
	Lambda Function	Anonymous one-line function	square = lambda x: x**2
	print(square(4))
	Scope	Local vs Global variables	x = 10
	def test():
		x = 5
		print(x)
	test()
	print(x)
	Docstring	Function description string	def greet():
		"""This says hello."""
		print('Hi')
	print(greet.__doc__)
	Recursion	A function calling itself	def fact(n):
		if n==0: return 1
		return n * fact(n-1)
	Function Annotations	Used for type hinting	def add(a: int, b: int) -> int:
		return a + b
	Nested Functions	Function defined inside another	def outer():
		def inner():
			print('Hi')
		inner()
	Closures	Function remembers its enclosing scope	def outer():
		msg = 'Hi'
		def inner():
			print(msg)
		return inner
	Decorators	Modifies another function	def deco(func):
		def wrap():
			print('Before')
			func()
		return wrap
	nonlocal	Modify outer variable from inner	def outer():
		x = 'old'
		def inner():
			nonlocal x
			x = 'new'
		inner()
		print(x)
	Higher-order Functions	Takes/returns other functions	def apply(func, val):
		return func(val)
	apply(lambda x: x*2, 5)


	| **Topic**                   | **Explanation**                          | **Code Example**                                                                    |
	| --------------------------- | ---------------------------------------- | ----------------------------------------------------------------------------------- |
	| **Function Definition**     | Define a function using `def` keyword    | `def greet():\n    print("Hello")`                                                  |
	| **Function Call**           | Execute a function                       | `greet()`                                                                           |
	| **Parameters**              | Variables in function definition         | `def greet(name):\n    print("Hello", name)`                                        |
	| **Arguments**               | Values passed to a function              | `greet("Shiffana")`                                                                 |
	| **Return Statement**        | Return a value to caller                 | `def add(a, b):\n    return a + b`                                                  |
	| **Default Parameters**      | Parameter with default value             | `def greet(name="Guest"):\n    print("Hello", name)`                                |
	| **Keyword Arguments**       | Pass values using parameter names        | `def student(name, age):\n    print(name, age)\n\nstudent(age=20, name="Ali")`      |
	| **`*args` (Positional)**    | Accept multiple positional args          | `def show(*args):\n    for i in args:\n        print(i)`                            |
	| **`**kwargs` (Keyword)**    | Accept multiple keyword args             | `def show(**kwargs):\n    for k, v in kwargs.items():\n        print(k, v)`         |
	| **Lambda Function**         | Anonymous one-line function              | `square = lambda x: x**2\nprint(square(4))`                                         |
	| **Scope (Local vs Global)** | Local variables are inside function only | `x = 10\n\ndef test():\n    x = 5\n    print(x)\n\ntest()\nprint(x)`                |
	| **Docstring**               | Function description string              | `def greet():\n    """This says hello."""\n    print("Hi")\n\nprint(greet.__doc__)` |

Object Oriented Programming:
```````````````````````````
  -  OOP (Object-Oriented Programming) is a programming paradigm that emphasizes the use of objects and 
		classes to represent and manipulate data. 
  -  In Python, you can use OOP concepts to design and create classes, objects, and methods that encapsulate 
		data and behavior into a single unit. 
		
Here are some of the key OOP concepts in Python:

Class:
`````` 
  -  A class is a blueprint or a template for creating objects. It defines the attributes (data) and 
  		methods (functions) that the objects of that class will have.

Object:
```````` 
  -  An object is an instance of a class. It is created from a class and has its own unique data and behavior. 
	 	Objects can be created, modified, and deleted dynamically during program execution.

Encapsulation: 
``````````````
  -	Encapsulation is the process of hiding the implementation details of a class from the outside world and 
		exposing only the necessary interface for interacting with the class. This helps to improve code
		modularity and reduce code complexity.

Inheritance: 
````````````
  -  Inheritance is the ability of a class to inherit the attributes and methods of another class. 
  -  It allows you to reuse existing code and create new classes that extend the functionality of existing classes.

Polymorphism: 
`````````````
  -  Polymorphism is the ability of different objects to respond to the same message (method call) in different ways. 
  -  It allows you to write code that can work with different types of objects without knowing their specific types at compile-time.

In Python, you can use these OOP concepts to create reusable, modular, and maintainable code that is easier to understand and debug. 
OOP can be a powerful tool for solving complex programming problems and building robust software systems.
    

Collections Module:
``````````````````````
	- The `collections` module provides specialized container datatypes that extend the built-in types like `list`, `dict`, and `set`.
	- These data structures are optimized for specific use cases, making them more efficient and easier to use in certain scenarios.
	```python
	from collections import Counter, defaultdict, deque, namedtuple, OrderedDict, ChainMap, UserDict

	| Collection Type | Import & Example Code                                                            | Purpose / Description                                                                                   | Example Output                               |
	| --------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
	| `Counter`       | `from collections import Counter`<br>`Counter("apple")`                          | üßÆ Counts how many times each item appears in a collection                                              | `{'p': 2, 'a': 1, 'l': 1, 'e': 1}`           |
	| `defaultdict`   | `from collections import defaultdict`<br>`d = defaultdict(int)`<br>`d['a'] += 1` | üîß Like a normal `dict`, but returns a **default value** when accessing missing keys                    | `{'a': 1, 'b': 0}`                           |
	| `deque`         | `from collections import deque`<br>`dq = deque([1, 2])`<br>`dq.appendleft(0)`    | ‚ÜîÔ∏è Double-ended queue ‚Äì fast adding/removing from **both ends**                                         | `deque([0, 1, 2])`                           |
	| `namedtuple`    | `from collections import namedtuple`<br>`Point = namedtuple("Point", "x y")`     | üè∑ A tuple with **named fields** ‚Äì acts like a lightweight class                                        | `p = Point(1, 2)` ‚Üí access like `p.x`, `p.y` |
	| `OrderedDict`   | `from collections import OrderedDict`<br>`od = OrderedDict()`                    | üìã Dictionary that remembers the **insertion order** (Note: normal `dict` does this in Python 3.7+)     | `{'a': 1, 'b': 2}`                           |
	| `ChainMap`      | `from collections import ChainMap`<br>`cm = ChainMap(dict1, dict2)`              | üîó Combines multiple dicts into a single view ‚Äì reads from first, falls back to second if key not found | `{'a': 1, 'b': 2}` (combined from 2 dicts)   |
	| `UserDict`      | `from collections import UserDict`<br>`class MyDict(UserDict): pass`            | üìñ Custom dictionary class that extends `dict` functionality                                          | `MyDict({'a': 1})`                            |

	Counter: 
	| Task / Feature                   | Example Code                      | Output / Description                                                 |                                                                                    |
	| -------------------------------- | --------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
	| **1. Count elements**            | `Counter("banana")`               | `Counter({'a': 3, 'n': 2, 'b': 1})` ‚Äì counts each character          |                                                                                    |
	| **2. Get count of a value**      | `c['a']`                          | `3` ‚Äì returns how many times `'a'` appears                           |                                                                                    |
	| **3. Safe access (missing key)** | `c['z']`                          | `0` ‚Äì returns `0` if the item does not exist (no error)              |                                                                                    |
	| **4. List all items**            | `c.items()`                       | `dict_items([('b', 1), ('a', 3), ('n', 2)])`                         |                                                                                    |
	| **5. List all keys only**        | `c.keys()`                        | `dict_keys(['b', 'a', 'n'])`                                         |                                                                                    |
	| **6. List all counts only**      | `c.values()`                      | `dict_values([1, 3, 2])`                                             |                                                                                    |
	| **7. Most common N items**       | `c.most_common(2)`                | `[('a', 3), ('n', 2)]` ‚Äì top 2 most frequent items                   |                                                                                    |
	| **8. All elements expanded**     | `list(c.elements())`              | `['b', 'a', 'a', 'a', 'n', 'n']` ‚Äì repeats each item by its count    |                                                                                    |
	| **9. Add two Counters**          | `Counter("abc") + Counter("bcd")` | `Counter({'b': 2, 'c': 2, 'a': 1, 'd': 1})`                          |                                                                                    |
	| **10. Subtract Counters**        | `Counter("abc") - Counter("bcd")` | `Counter({'a': 1})` ‚Äì subtracts counts, removes negatives            |                                                                                    |
	| **11. Minimum (Intersection)**   | `Counter("abc") & Counter("bcd")` | `Counter({'b': 1, 'c': 1})` ‚Äì keeps the lower count for common items |                                                                                    |
	| **12. Maximum (Union)**          | \`Counter("abc")                  | Counter("bcd")\`                                                     | `Counter({'b': 1, 'c': 1, 'a': 1, 'd': 1})` ‚Äì keeps the higher count for each item |
	| **13. Update with more data**    | `c.update("ana")`                 | Adds counts from "ana" to the existing Counter                       |                                                                                    |
	| **14. Delete an item**           | `del c['a']`                      | Removes the item `'a'` entirely from the Counter                     |                                                                                    |
	| **15. Clear all counts**         | `c.clear()`                       | Empties the Counter, making it empty                                 |                                                                                    |
	| **16. Convert to dict**          | `dict(c)`                         | Converts Counter to a regular dictionary                             |                                                                                    |