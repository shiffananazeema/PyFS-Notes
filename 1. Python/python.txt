Python: 
```````
 	- Popular Programming Language - Guido van Rossum in 1991 at CWI in the Netherlands
	- Python is an interpreted, high-level, general-purpose programming language.
	- It is designed to be easy to read and write, with a focus on code readability and simplicity.	
	- Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming.

1. Reserved words or Keywords:
2. Variable:
3. Data Types:
4. Operations:
5. Operators:
6. Flow Control:
7. Collection Data Types:
8. Functions:
9. Object Oriented Programming:

[Qucik Search: Select -> Contol + f -> Enter]

1. Reserved words or Keywords:
```````````````````````````````

	- Keywords have special meanings to the compiler. There are 37 keywords.
	- They cannot be used as identifiers (variable names, function names, etc.)
	- Keywords are case-sensitive, meaning that they must be written in lowercase.

	False		await		else		import		pass		match
	None		break	   	except		in			raise 		case
	True		class	   	finally		is			return
	and 		continue   	for			lambda		try
	as 			def 	   	from		nonlocal	while
	assert		del   	   	global		not			with
	async		elif	   	if			or			yield

	Value Keywords				- 	True, False, None
	Operator Keywords			- 	and, or, not, in, is
	Control Flow Keywords		- 	if, elif, else, match, case
	Iteration Keywords			- 	for, while, break, continue, pass
	Structure Keywords			- 	def, class, with, lambda
	Returning Keywords			-	return, yield
	Import Keywords				- 	import, from, as
	Exception-Handling Keywords -	try, except, raise, finally, assert
	Asynchronous Keywords	  	- 	async, await
	Variable Handling Keywords  - 	del, global, nonlocal


	True, False - Boolean value
	Eg:
		x = True			y = False
		x is True			y is not True
		# True			# True
		
	None - Represents no Value
	Eg:
		def func():				- can't print the call 
			print("hello")			- can't print the print
		x = func()
		# hello
		print(x)			
		# None
    
2. Variable:
````````````
	Cotainers for storing data values. 
	Literals - Raw data assigned to a Variable or Constant
	Python is a dynamically-typed language, and there is no built-in mechanism to enforce constant values.
	Variable naming rules (e.g., no starting with numbers, no special characters except _).	
		- Python is case sensitive. Eg: y and Y are Different

	name  = "Shiffana" 
	|	      |
	Variable   Literal

3. Data Types:
``````````````
	- Data types are classifications of data that determine the kind of value a variable can hold and the operations that can be performed on it.
	- Python is a dynamically typed language, meaning you don't need to declare the data type of a variable explicitly.
	- In Python, there are several built-in data types that you can use to store different kinds of data. 
		Here is a comprehensive list of all the data types in Python:

	|   Category         |   Type       |   Description                                     |   Example                           |
	| ------------------ | ------------ | ------------------------------------------------- | ----------------------------------- |
	| 1 Numeric Types    |  int         | Whole numbers, positive or negative               |  x = 10                             |
	|                    |  float       | Numbers with decimal points                       |  pi = 3.14                          |
	|                    |  complex     | Numbers with real and imaginary parts             |  z = 2 + 3j                         |
	| 2 Text Type        |  str         | Sequence of characters (Unicode)                  |  name = "Alice"                     |
	| 3 Boolean Type     |  bool        | Logical values: True or False                     |  is_active = True                   |
	| 4 Sequence Types   |  list        | Mutable ordered sequence                          |  fruits = ["apple", "banana"]       |
	|                    |  tuple       | Immutable ordered sequence                        |  point = (10, 20)                   |
	|                    |  range       | Immutable range of numbers                        |  numbers = range(5)                 |
	| 5 Mapping Type     |  dict        | Key-value pair collection                         |  user = {"name": "Bob", "age": 30}  |
	| 6 Set Types        |  set         | Unordered collection of unique elements (mutable) |  s = {1, 2, 3}                      |
	|                    |  frozenset   | Unordered unique collection (immutable)           |  fs = frozenset([1, 2, 3])          |
	| 7 Binary Types     |  bytes       | Immutable byte sequence                           |  b = b"hello"                       |
	|                    |  bytearray   | Mutable byte sequence                             |  ba = bytearray(b"data")            |
	|                    |  memoryview  | View over byte data                               |  mv = memoryview(b"abc")            |
	| 8 None Type        |  NoneType    | Represents absence of value                       |  result = None ; type(None)         |


	Data Type:			Type Casting:	- Changing the type of data
	``````````			`````````````
	print(type(x))		x = int("3")		

4. Operations: 
``````````````
	- Operations are actions performed on data types using operators or methods.
	- They allow you to manipulate, compare, and transform data.
	- Tuples and dictionaries support indexing and key-based access

	1. String Operations 

		|   Operation      |   Description                                  |   Example                          |
		| ---------------- | ---------------------------------------------- | ---------------------------------- |
		|  ' '  /  " "     | Define a string                                |  'Hello' ,  "World"                |
		|  len()           | Length of the string                           |  len("Python") → 6                 |
		|  in ,  not in    | Check if a substring exists                    |  "a" in "cat" → True               |
		| Indexing         | Access character by position                   |  "Hello"[1] → 'e'                  |
		| Slicing          | Access part of the string                      |  "Hello"[1:4] → 'ell'              |
		|  upper()         | Convert to uppercase                           |  "hi".upper() → "HI"               |
		|  lower()         | Convert to lowercase                           |  "HI".lower() → "hi"               |
		|  capitalize()    | Capitalize first character                     |  "python".capitalize() → "Python"  |
		|  strip()         | Remove whitespace from both ends               |  "  hi  ".strip() → "hi"           |
		|  replace()       | Replace parts of a string                      |  "hi".replace("h", "H") → "Hi"     |
		|  split()         | Split into list by delimiter                   |  "a,b".split(",") → ['a', 'b']     |
		|  format()        | Format strings with placeholders  {}           |  "Hello {}".format("World")        |
		|  find()          | Find first occurrence of substring             |  "apple".find("p") → 1             |
		|  rfind()         | Find last occurrence of substring              |  "banana".rfind("a") → 5           |
		|  index()         | Like  find()  but raises error if not found    |  "abc".index("b") → 1              |
		|  startswith()    | Check if string starts with value              |  "apple".startswith("a") → True    |
		|  endswith()      | Check if string ends with value                |  "apple".endswith("e") → True      |
		|  isalpha()       | Check if all characters are letters            |  "abc".isalpha() → True            |
		|  isdigit()       | Check if all characters are digits             |  "123".isdigit() → True            |
		|  isalnum()       | Check if all characters are alphanumeric       |  "abc123".isalnum() → True         |
		|  isupper()       | Check if all characters are uppercase          |  "HELLO".isupper() → True          |
		|  islower()       | Check if all characters are lowercase          |  "hello".islower() → True          |
		|  join()          | Join iterable into string                      |  ",".join(["a", "b"]) → "a,b"      |
		|  zfill()         | Pad string on the left with zeros              |  "7".zfill(3) → "007"              |
		| Escape Sequences | Special characters: newline, tab, quotes, etc. |  \n ,  \t ,  \' ,  \\ ,  \"        |

	2. List Operations

		|   Operation          |   Description                                     |   Example                             |
		| -------------------- | ------------------------------------------------- | ------------------------------------- |
		|  len()               | Get number of items in the list                   |  len([1, 2, 3]) → 3                   |
		|  in ,  not in        | Check if item exists in the list                  |  "apple" in fruits → True             |
		| Indexing             | Access item by index                              |  fruits[0] → "apple"                  |
		| Slicing              | Get sublist by range                              |  fruits[1:3] → ['banana', 'mango']    |
		|  count()             | Count occurrences of an item                      |  fruits.count("apple") → 2            |
		|  index()             | Find index of the first matching item             |  fruits.index("banana") → 1           |
		| Change Item          | Modify item by index                              |  fruits[1] = "grape"                  |
		|  insert()            | Insert item at a specific index                   |  fruits.insert(2, "melon")            |
		|  append()            | Add item to the end of the list                   |  fruits.append("kiwi")                |
		|  extend()            | Add multiple items from another list              |  fruits.extend(["peach", "plum"])     |
		|  remove()            | Remove first occurrence of an item                |  fruits.remove("apple")               |
		|  pop()               | Remove item at index or last if no index provided |  fruits.pop(1) ,  fruits.pop()        |
		|  del                 | Delete item by index or entire list               |  del fruits[1] ,  del fruits          |
		|  clear()             | Remove all items from the list                    |  fruits.clear()                       |
		|  sort()              | Sort list in ascending order                      |  fruits.sort()                        |
		|  sort(reverse=True)  | Sort list in descending order                     |  fruits.sort(reverse=True)            |
		|  reverse()           | Reverse the list order                            |  fruits.reverse()                     |
		|  copy()              | Create a shallow copy of the list                 |  new_list = fruits.copy()             |
		| List Comprehension   | Create list using loop and condition              |  [x for x in range(5) if x % 2 == 0]  |

	3. Set Operations

		|   Operation              |   Description                                  |   Example                     |
		| ------------------------ | ---------------------------------------------- | ----------------------------- |
		|  add()                   | Adds an element to the set                     |  s.add(5)                     |
		|  update()                | Adds multiple elements                         |  s.update([1, 2, 3])          |
		|  remove()                | Removes element; error if not found            |  s.remove(2)                  |
		|  discard()               | Removes element if present; no error if absent |  s.discard(10)                |
		|  pop()                   | Removes a random element                       |  s.pop()                      |
		|  clear()                 | Removes all elements                           |  s.clear()                    |
		|  union()                 | Returns union of two sets                      |  s1.union(s2)                 |
		|  intersection()          | Returns common elements                        |  s1.intersection(s2)          |
		|  difference()            | Returns items only in first set                |  s1.difference(s2)            |
		|  symmetric_difference()  | Items in either, but not both sets             |  s1.symmetric_difference(s2)  |
		|  issubset()              | Checks if set is subset                        |  s1.issubset(s2)              |
		|  issuperset()            | Checks if set is superset                      |  s1.issuperset(s2)            |
		|  isdisjoint()            | Checks if sets have no items in common         |  s1.isdisjoint(s2)            |

	4. Tuple Operations 

		|   Operation   |   Description                          |   Example                 |
		| ------------- | -------------------------------------- | ------------------------- |
		| Indexing      | Access item by index                   |  t[1] → 'banana'          |
		| Slicing       | Access a range of items                |  t[1:3]                   |
		|  count()      | Count occurrences of a value           |  t.count("apple") → 2     |
		|  index()      | Find index of a value                  |  t.index("banana") → 1    |
		|  in           | Check if value exists                  |  "apple" in t → True      |
		|  len()        | Length of tuple                        |  len(t) → 3               |
		| Immutability  | Cannot be modified after creation      |  t[0] = "new"  ❌ Error   |
		| Nesting       | Tuples can contain lists, other tuples |  t = (1, [2, 3], (4, 5))  |

	5. Dictionary Operations
		|   Operation   |   Description                                     |   Example                |
		| ------------- | ------------------------------------------------- | ------------------------ |
		|  get()        | Gets value by key (returns None if not found)     |  d.get("name")           |
		|  keys()       | Returns list-like view of all keys                |  d.keys()                |
		|  values()     | Returns list-like view of all values              |  d.values()              |
		|  items()      | Returns view of key-value pairs                   |  d.items()               |
		|  update()     | Updates dictionary with another dict or key-value |  d.update({"age": 30})   |
		|  pop()        | Removes key and returns its value                 |  d.pop("name")           |
		|  popitem()    | Removes and returns last key-value pair           |  d.popitem()             |
		|  del          | Deletes key or entire dict                        |  del d["name"] ,  del d  |
		|  clear()      | Empties the dictionary                            |  d.clear()               |
		|  in           | Check if key exists                               |  "name" in d → True      |
		| Indexing      | Access or assign value with key                   |  d["name"] = "Ali"       |

	6. File Operations

	|   Operation    |   Description                                            |   Example                      |
	| -------------- | -------------------------------------------------------- | ------------------------------ |
	|  open()        | Opens a file ( 'r' ,  'w' ,  'a' ,  'rb' ,  'wb' , etc.) |  f = open("file.txt", "r")     |
	|  read()        | Reads entire file content                                |  f.read()                      |
	|  readline()    | Reads one line                                           |  f.readline()                  |
	|  readlines()   | Reads all lines into a list                              |  f.readlines()                 |
	|  write()       | Writes content (overwrites in  'w'  mode)                |  f.write("Hello")              |
	|  writelines()  | Writes a list of strings to a file                       |  f.writelines(["a\n", "b\n"])  |
	|  close()       | Closes the file                                          |  f.close()                     |
	|  with open()   | Context manager to open file (auto-close)                |  with open("file.txt") as f:   |
	|  seek()        | Move the file cursor to given position                   |  f.seek(0)                     |
	|  tell()        | Returns current file position                            |  f.tell()                      |
	|  flush()       | Force write buffer to disk                               |  f.flush()                     |

5. Operators:
``````````````
	- Operators are symbols that perform operations on variables and values.
	- They are used to manipulate data and variables in Python.
	- Operators can be classified into several categories based on their functionality.

	1. Arithmetic Operator	
			- Numeric values to perform common Mathematical Operations
				
				+ , - , * , / , % , ** , // 

		| Operator | Name           | Description                               | Example        |
		| -------- | -------------- | ----------------------------------------- | -------------- |
		|  +       | Addition       | Adds two values                           | 3 + 2 = 5     |
		|  -       | Subtraction    | Subtracts right operand from left         |  5 - 2 = 3     |
		|  *       | Multiplication | Multiplies both values                    |  4 * 3 = 12    |
		|  /       | Division       | Divides left by right (float result)      |  10 / 4 = 2.5  |
		|  //      | Floor Division | Divides and removes decimal (rounds down) |  10 // 4 = 2   |
		|  %       | Modulo         | Returns remainder                         |  10 % 3 = 1    |
		|  **      | Exponentiation | Power of (left raised to right)           |  2 ** 3 = 8    |
				
	2. Assignment Operator	
			- Assign values to Variables 
				
				= , += , -=, *= , /=, %=, **=, //= , &= , |= , ^= , >>= , <<= 

		| Operator | Name                | Description       | Example   |   
		| -------- | ------------------- | ----------------- | --------- | 
		|  =       | Assignment          | Assigns value     |  x = 5    |     
		|  +=      | Add AND assign      |  x = x + 3        |  x += 3   |    
		|  -=      | Subtract AND assign |  x = x - 2        |  x -= 2   |     
		|  *=      | Multiply AND assign |  x = x * 4        |  x *= 4   |   
		|  /=      | Divide AND assign   |  x = x / 2        |  x /= 2   |  
		|  //=     | Floor divide assign |  x = x // 2       |  x //= 2  |  
		|  %=      | Modulo AND assign   |  x = x % 2        |  x %= 2   |   
		|  **=     | Power AND assign    |  x = x ** 2       |  x **= 2  |    
		|  &=      | Bitwise AND assign  |  x = x & 1        |  x &= 1   |   
		|  |=      | Bitwise OR assign   |  x = x | 2        |  x |= 2   | 
		|  ^=      | Bitwise XOR assign  |  x = x ^ 3        |  x ^= 3   |     
		|  >>=     | Right shift assign  |  x = x >> 1       |  x >>= 1  |    
		|  <<=     | Left shift assign   |  x = x << 1       |  x <<= 1  |    
	
	3. Comparison Operator	
			- Compare two values
				
				== , != , > , < , >= , <=

		| Operator | Description              | Example  |
		| -------- | ------------------------ | -------- |
		|  ==      | Equal to                 |  x == y  |
		|  !=      | Not equal to             |  x != y  |
		|  >       | Greater than             |  x > y   |
		|  <       | Less than                |  x < y   |
		|  >=      | Greater than or equal to |  x >= y  |
		|  <=      | Less than or equal to    |  x <= y  |
				
	4. Logical Operator	
			- Combine Conditional Statements
				
				and , or , not 

		| Operator | Description                      | Example            |
		| -------- | -------------------------------- | ------------------ |
		|  and     | True if both conditions are True |  x > 2 and x < 10  |
		|  or      | True if one condition is True    |  x < 5 or x > 20   |
		|  not     | Reverses the condition           |  not(x == 5)       |
				
	5. Identity Operator	
			- Compare the objects
				
				is , is not

		| Operator | Description                                 | Example      |
		| -------- | ------------------------------------------- | ------------ |
		|  is      | True if both variables point to same object |  x is y      |
		|  is not  | True if they don't point to same object     |  x is not y  |
				
	6. Membership Operator	
			- Test is a sequence is present
				
				in , not in

		| Operator | Description                   | Example            |
		| -------- | ----------------------------- | ------------------ |
		|  in      | True if value is in sequence  |  "a" in "apple"    |
		|  not in  | True if value not in sequence |  "z" not in "dog"  |

	7. Bitwise Operator	
 		- Compare Binary Numbers
 			
			 & , | , ^ , ~ , << , >>
			
		| Operator | Description        | Example (in binary)       |     
		| -------- | ------------------ | ------------------------- |
		|  &       | AND                |  5 & 3 → 101 & 011 = 001  |    
		|  |       | OR                 |  5 | 3 → 101 | 011 = 111  |                    
		|  ^       | XOR (exclusive OR) |  5 ^ 3 → 101 ^ 011 = 110  |   
		|  ~       | NOT (inverts bits) |  ~5 → -(5+1) = -6         |  
		|  <<      | Left shift         |  2 << 1 → 4  (10 → 100)   |    
		|  >>      | Right shift        |  4 >> 1 → 2  (100 → 10)   |    

6. Flow Control:
`````````````````
	- Flow control statements determine the order in which statements are executed in a program.
	- They allow you to control the flow of execution based on conditions, loops, and exceptions.
	- Flow control statements are essential for making decisions, repeating actions, and handling errors in your code.

	1. Conditional Statement
			- It lets the program decide which block of code to execute based on the condition. Decision making.

		|  Name      |  Definition                                          |  Syntax                 |  Example                            |
		| ---------- | ---------------------------------------------------- | ----------------------- | ----------------------------------- |
		|  if        | Runs a block of code if the condition is True        |  if condition:          |  if x > 10:\n    print("Big")       |
		|  elif      | Runs if the  if  is False and this condition is True |  elif condition:        |  elif x == 10:\n    print("Equal")  |
		|  else      | Runs if all above conditions are False               |  else:                  |  else:\n    print("Small")          |
		| Ternary if | One-line conditional expression                      |  x if condition else y  |  result = "Yes" if x > 0 else "No"  |

	2. Looping Statement
			- Used to repeate a block of code multiple times.

		|  Name    |  Definition                              |  Syntax                |  Example                           |
		| -------- | ---------------------------------------- | ---------------------- | ---------------------------------- |
		|  for     | Iterates over items in a sequence        |  for var in sequence:  |  for i in range(3):\n    print(i)  |
		|  while   | Repeats code while the condition is True |  while condition:      |  while x < 5:\n    x += 1          |

	3. Loop Control Statement
			- Used to alter the flow of loops: exit early, skip iterations or do nothing.

		|  Name          |  Definition                                       |  Syntax               |  Example                                     |
		| -------------- | ------------------------------------------------- | --------------------- | -------------------------------------------- |
		|  break         | Exits the loop immediately                        |  break                |  if x == 3:\n    break                       |
		|  continue      | Skips the rest of the loop iteration              |  continue             |  if x % 2 == 0:\n    continue                |
		|  pass          | Does nothing (placeholder)                        |  pass                 |  if True:\n    pass                          |
		|  else  on loop | Executes if the loop was not exited using  break  |  for/while ... else:  |  for i in range(3): ... else: print("Done")  |

	4. Exception Handling Statement
			- Used to handle errors or unexpected conditions gracefully without crashing the program

	|   Concept                  |   Explanation                               |   Use Case                        |   Example                                                                                                                                     |
	| -------------------------- | ------------------------------------------- | --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
	|   try-except               | Catch and handle errors gracefully          | Prevent crash when input is wrong | `python\ntry:\n    x = int(input("Enter a number: "))\nexcept ValueError:\n    print("Invalid input")`                                        |
	|   Multiple except blocks   | Catch specific error types                  | Handle errors differently         | `python\ntry:\n    x = 10 / 0\nexcept ZeroDivisionError:\n    print("Cannot divide by zero")\nexcept ValueError:\n    print("Invalid value")` |
	|   else block               | Runs only if no exception occurred          | Perform actions when no errors    | `python\ntry:\n    x = int(input())\nexcept ValueError:\n    print("Invalid")\nelse:\n    print("Success", x)`                                |
	|   finally block            | Always runs, error or not                   | Clean up (e.g., close files)      | `python\ntry:\n    f = open("file.txt")\nexcept FileNotFoundError:\n    print("Not found")\nfinally:\n    print("Done")`                      |
	|   raise                    | Manually throw an error                     | Validate data, custom checks      | `python\ndef set_age(age):\n    if age < 0:\n        raise ValueError("Age can't be negative")`                                               |
	|   Custom Exception         | Create specific errors using custom classes | Business logic validation         | `python\nclass MyError(Exception):\n    pass\n\nraise MyError("Something went wrong")`                                                        |


	5. Match Statement
			- Pattern matching allows matching values and executing corresponding code blocks, similar to switch in other languages.

		|  Name    |  Definition                               |  Syntax           |  Example                        |
		| -------- | ----------------------------------------- | ----------------- | ------------------------------- |
		|  match   | Start of the pattern matching structure   |  match variable:  |  match status:                  |
		|  case    | Handles each pattern                      |  case value:      |  case 200:\n    print("OK")     |
		|  case _  | Catch-all case (like  default  in switch) |  case _:          |  case _:\n    print("Unknown")  |

	6. Assert Statement
		- Used to debugging. It tests if a condition is True; if not, it raises an AssertionError.

	|  Name    |  Definition                  |  Syntax            |  Example                             |
	| -------- | ---------------------------- | ------------------ | ------------------------------------ |
	|  assert  | Tests if a condition is True |  assert condition  |  assert x > 0, "x must be positive"  |
		
7. Collection Data Types:
``````````````````````````
	- Collection data types are used to store multiple items in a single variable.
	- They allow you to group related data together and perform operations on the entire collection.	
	- Python has several built-in collection data types, each with its own characteristics and use cases.


	| Type          | Ordered | Mutable | Allows Duplicates | Unique Feature                     | Example                        |
	| ------------- | ------- | ------- | ----------------- | ---------------------------------- | ------------------------------ |
	|   List        |   Yes   |   Yes   |   Yes             | Ideal for ordered, changeable data | `["a", "b", "c"]`              |
	|   Tuple       |   Yes   |   No    |   Yes             | Immutable list                     | `("a", "b", "c")`              |
	|   Set         |   No    |   Yes   |   No              | Only unique items                  | `{"a", "b", "c"}`              |
	|   Frozenset   |   No    |   No    |   No              | Immutable version of set           | `frozenset(["a", "b", "c"])`   |
	|   Dict        |   Yes   |   Yes   |   (Keys)          | Key-value pairs                    | `{"name": "Alice", "age": 25}` |

	1. List – Use when you need a dynamic and ordered collection (e.g., shopping list).
	2. Tuple – Use when the data should not change (e.g., GPS coordinates).
	3. Set – Use when you want to store unique values (e.g., removing duplicates).
	4. Dictionary – Use when you want to map keys to values (e.g., storing employee data).
	5. frozenset – Use when you want a constant set (e.g., as a dictionary key or for hashable needs).

8. Functions:
`````````````
	- Functions are reusable blocks of code that perform a specific task.
	- They help organize code, avoid repetition, and make it easier to read and maintain.	
	- Functions can take inputs (parameters) and return outputs (return values).
	- Python supports both built-in functions and user-defined functions.
	

	|   Concept                    |   Explanation                         |   Use Case                         |   Example                                                                                                                                           |
	| ---------------------------- | ------------------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
	|   Function Definition        | Use `def` to create a function        | Reusable code blocks               |  python\ndef greet():\n    print("Hello")                                                                                                           |
	|   Function Call              | Executes function code                | Trigger functionality              |  python\ngreet()                                                                                                                                    |
	|   Parameters                 | Input variables in definition         | Customize behavior                 |  python\ndef greet(name):\n    print("Hello", name)                                                                                                 |
	|   Arguments                  | Actual values passed                  | Provide input                      |  python\ngreet("Shiffana")                                                                                                                          |
	|   Return Statement           | Sends value to caller                 | Use result in code                 |  python\ndef add(a, b):\n    return a + b                                                                                                           |
	|   Default Parameters         | Use default if no argument given      | Optional arguments                 |  python\ndef greet(name="Guest"):\n    print("Hello", name)                                                                                         |
	|   Keyword Arguments          | Specify parameter names               | Avoid ordering issues              |  python\ndef student(name, age):\n    print(name, age)\n\nstudent(age=20, name="Ali")                                                               |
	|   `*args` (Positional)       | Accept multiple positional args       | Accept unlimited inputs            |  python\ndef show(*args):\n    for i in args:\n        print(i)                                                                                     |
	|   `**kwargs` (Keyword)       | Accept multiple keyword args          | Flexible named arguments           |  python\ndef show(**kwargs):\n    for k, v in kwargs.items():\n        print(k, v)                                                                  |
	|   Lambda Function            | One-line anonymous function           | Inline short logic                 |  python\nsquare = lambda x: x ** 2\nprint(square(4))                                                                                                |
	|   Higher-order Functions     | Takes or returns other functions      | Flexible function passing          |  python\ndef apply(func, val):\n    return func(val)\n\napply(lambda x: x * 2, 5)                                                                   |
	|   Function Annotations       | Type hints for readability            | IDE help, static checks            |  python\ndef add(a: int, b: int) -> int:\n    return a + b                                                                                          |
	|   Docstring                  | Function documentation string         | Explain purpose of function        |  python\ndef greet():\n    """This says hello."""\n    print("Hi")\n\nprint(greet.__doc__)                                                          |
	|   Scope                      | Local vs global variables             | Prevent accidental overwrite       |  python\nx = 10\n\ndef test():\n    x = 5\n    print(x)\n\ntest()\nprint(x)                                                                         |
	|   nonlocal                   | Modify outer function’s variable      | Update nested scope variable       |  python\ndef outer():\n    x = 'old'\n    def inner():\n        nonlocal x\n        x = 'new'\n    inner()\n    print(x)                            |
	|   Nested Functions           | Define function inside another        | Limit scope of helper functions    |  python\ndef outer():\n    def inner():\n        print("Hi")\n    inner()                                                                           |
	|   Closures                   | Inner function remembers outer values | Preserve state                     |  python\ndef outer():\n    msg = 'Hi'\n    def inner():\n        print(msg)\n    return inner                                                       |
	|   Decorators                 | Modify behavior of another function   | Logging, auth, timing              |  python\ndef deco(func):\n    def wrap():\n        print("Before")\n        func()\n    return wrap                                                 |
	|   Recursion                  | Function calling itself               | Factorial, Fibonacci, backtracking |  python\ndef fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)                                                                 |
	|    __name__ == '__main__'    | Run code only if not imported         | Script reuse and testing           |  python\ndef main():\n    print("Running directly")\n\nif __name__ == "__main__":\n    main()                                                       |
	|    functools.partial         | Fix some arguments in advance         | Preconfigure function behavior     |  python\nfrom functools import partial\n\ndouble = partial(pow, 2)\nprint(double(3))                                                                |
	|    functools.lru_cache       | Memoize results to speed up function  | Cache expensive calls              |  python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)  |
	|   Function Introspection     | Access metadata like name/doc         | Debugging and reflection           |  python\ndef f():\n    """Sample"""\n    pass\n\nprint(f.__name__)\nprint(f.__doc__)                                                                |
	|   Async Functions            | Support async programming             | Concurrent I/O, networking         |  python\nimport asyncio\n\nasync def greet():\n    await asyncio.sleep(1)\n    print("Hello")                                                       |
	|   Generator Functions        | Yield values one at a time            | Handle large data streams          |  python\ndef count_up():\n    yield 1\n    yield 2\n    yield 3                                                                                     |
	|   Callable Objects           | Objects behaving like functions       | Advanced OOP use                   |  python\nclass Greeter:\n    def __call__(self):\n        print("Hello")\n\ng = Greeter()\ng()                                                      |
	|   Function Overloading       | Same name, different signatures       | Not supported directly in Python   |  python\n# Use default args or variable args instead\n\ndef add(x, y=0):\n    return x + y\n\nprint(add(5))\nprint(add(5, 10))                        |


9. Object Oriented Programming:
```````````````````````````````
	-  OOP (Object-Oriented Programming) is a programming paradigm that emphasizes the use of objects and 
			classes to represent and manipulate data. 
	-  In Python, you can use OOP concepts to design and create classes, objects, and methods that encapsulate 
			data and behavior into a single unit. 
			
	Here are some of the key OOP concepts in Python:

	Class:
	`````` 
	-  A class is a blueprint or a template for creating objects. It defines the attributes (data) and 
			methods (functions) that the objects of that class will have.

	Object:
	```````` 
	-  An object is an instance of a class. It is created from a class and has its own unique data and behavior. 
			Objects can be created, modified, and deleted dynamically during program execution.

	| Concept    | Explanation                      | Use Case                                             | Example                           |
	| ---------- | -------------------------------- | ---------------------------------------------------- | --------------------------------- |
	|   Class    | A blueprint for creating objects | Model real-world entities like users, cars, products |  python\nclass Person:\n    pass  |
	|   Object   | An instance of a class           | Create usable data from the blueprint                |  python\np1 = Person()            |

	Encapsulation: 
	``````````````
	-	Encapsulation is the process of hiding the implementation details of a class from the outside world and 
			exposing only the necessary interface for interacting with the class. This helps to improve code
			modularity and reduce code complexity.

	| Concept           | Explanation           | Use Case                                | Example                                                                                                                                                                                           |
	| ----------------- | --------------------- | --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	|   Encapsulation   | Hide internal details | Protect data from external modification |  python\nclass Bank:\n    def __init__(self):\n        self.__balance = 0\n    def deposit(self, amt):\n        self.__balance += amt\n    def get_balance(self):\n        return self.__balance  |

	Inheritance: 
	````````````
	-  Inheritance is the ability of a class to inherit the attributes and methods of another class. 
	-  It allows you to reuse existing code and create new classes that extend the functionality of existing classes.

	| Concept         | Explanation                                      | Use Case                                | Example                                                                                                                                                                     |
	| --------------- | ------------------------------------------------ | --------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	|   Inheritance   | One class (child) inherits from another (parent) | Reuse code and create class hierarchies |  python\nclass Animal:\n    def speak(self):\n        print(\"Makes sound\")\n\nclass Dog(Animal):\n    def speak(self):\n        print(\"Barks\")\n\nd = Dog()\nd.speak()  |

	Polymorphism: 
	`````````````
	-  Polymorphism is the ability of different objects to respond to the same message (method call) in different ways. 
	-  It allows you to write code that can work with different types of objects without knowing their specific types at compile-time.

	| Concept          | Explanation                                                | Use Case                         | Example                                                                                                                                                                                                                 |
	| ---------------- | ---------------------------------------------------------- | -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	|   Polymorphism   | Same method name behaves differently for different classes | Write flexible and reusable code |  python\nclass Cat:\n    def sound(self):\n        print(\"Meow\")\n\nclass Dog:\n    def sound(self):\n        print(\"Bark\")\n\ndef make_sound(animal):\n    animal.sound()\n\nmake_sound(Cat())\nmake_sound(Dog())  |
	
	Abstraction:
	````````````` 
	-  Abstraction is the process of simplifying complex systems by breaking them down into smaller, more manageable parts. 
	-  It allows you to focus on the essential features of an object while ignoring the irrelevant details.
	
	| Concept         | Explanation                                               | Use Case                                    | Example                                                                                                                                                                                                                                                                |
	| --------------- | --------------------------------------------------------- | ------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	|   Abstraction   | Hiding implementation details using abstract base classes | Enforce structure and method implementation |  python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side * self.side  |

	Other OOP Concepts:
	````````````````````
	-  Python also supports other OOP concepts like method overloading, operator overloading, and multiple inheritance.
	-  These concepts allow you to customize the behavior of classes and objects in Python.
	
	| Concept         			| Explanation                               | Use Case             						| Example                                                                                                                  |
	| ------------------------- | ----------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
	| __init__() Constructor 	| Automatically runs when object is created | Set up initial state 						|  python\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\np1 = Person(\"Ali\")\nprint(p1.name)  |
	|   Instance Variable   	| Unique for each object 					| Store individual object data 				|  python\nclass Dog:\n    def __init__(self, name):\n        self.name = name  |
	|   Class Variable     		| Shared by all objects  					| Common property like species 				|  python\nclass Dog:\n    species = 'Canine'                                   |
	|   Instance Method  		| Takes `self` as first argument 			| Access or modify object state            	|  python\ndef bark(self):\n    print(self.name, 'barks')                                   |
	|   Class Method      		| Takes `cls` as first argument  			| Factory methods, change class-level data 	|  python\n@classmethod\ndef set_species(cls, new_species):\n    cls.species = new_species  |
	|   Static Method     		| No `self` or `cls`             			| Utility functions related to class       	|  python\n@staticmethod\ndef info():\n    print('Dogs are animals')                        |
	|    super()    			| Call a method from the parent class 		| Reuse parent behavior while extending it 	|  python\nclass Animal:\n    def __init__(self):\n        print(\"Animal created\")\n\nclass Dog(Animal):\n    def __init__(self):\n        super().__init__()\n        print(\"Dog created\")\n\nDog()  |
	|   `__str__` and `__repr__`| Control how objects are printed     		| Improve debugging and display            	|  python\nclass Book:\n    def __init__(self, title):\n        self.title = title\n    def __str__(self):\n        return f\"Book: {self.title}\"\n\nb = Book(\"Python\")\nprint(b)  |
	|   Other common ones       | `__add__`, `__eq__`, `__len__` etc. 		| Customize behavior of built-in operators 	|  python\nclass Point:\n    def __init__(self, x):\n        self.x = x\n    def __add__(self, other):\n        return Point(self.x + other.x)                                        |
	|   Protected (`_var`)      | Meant for internal use (not enforced) 	| Convention only          					|  python\nclass Person:\n    def __init__(self):\n        self._age = 30        |
	|   Private (`__var`)       | Name mangled to prevent access        	| Restrict external access 					|  python\nclass Person:\n    def __init__(self):\n        self.__salary = 5000  |
	|    @property    			| Makes method read-only attribute 			| Hide complex logic behind simple access 	|  python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def area(self):\n        return 3.14 * self._radius ** 2\n\nc = Circle(5)\nprint(c.area)  # no () needed  |
	|   Composition   			| Use one class inside another 				| Better for "has-a" relationship 			|  python\nclass Engine:\n    def start(self):\n        print(\"Engine started\")\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine()\n\nc = Car()\nc.engine.start()  |
	|   Inheritance   			| Derive from another class    				| Better for "is-a" relationship  			|  python\nclass Vehicle:\n    pass\nclass Bike(Vehicle):\n    pass                                                                                                                      |
	|   Duck Typing   			| quack like duck base on behavior not type | Flexible code without enforcing types 	|  python\nclass Duck:\n    def quack(self):\n        print(\"Quack\")\n\nclass Person:\n    def quack(self):\n        print(\"I'm quacking like a duck!\")\n\ndef make_it_quack(entity):\n    entity.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(Person())  |
	|   Multiple Inheritance   	| Class inherits from multiple parents 		| Combine behavior from multiple classes 	|  python\nclass Father:\n    def work(self):\n        print(\"Engineer\")\n\nclass Mother:\n    def cook(self):\n        print(\"Chef\")\n\nclass Child(Father, Mother):\n    pass\n\nc = Child()\nc.work()\nc.cook()  |

	- In Python, you can use these OOP concepts to create reusable, modular, and maintainable code that is easier to understand and debug. 
	- OOP can be a powerful tool for solving complex programming problems and building robust software systems.
    
10. File Handling:
````````````````
	- File handling in Python allows you to read from and write to files on your system.
	- It is essential for data persistence, allowing you to store and retrieve information between program runs.
	- Python provides built-in functions and methods for file operations, making it easy to work with files.

	|   Concept              |   Explanation                                 |   Use Case              |   Example                                                  |
	| ---------------------- | --------------------------------------------- | ----------------------- | ---------------------------------------------------------- |
	|   Opening a File       | Use  open()  to open a file                   | Access or create a file |  python\nf = open("file.txt", "r")                         |
	|   Reading a File       |  read() ,  readline() ,  readlines()  methods | Load file contents      |  python\ncontent = f.read()                                |
	|   Writing to a File    | Use  "w"  (overwrite) or  "a"  (append) mode  | Save data to file       |  python\nf = open("file.txt", "w")\nf.write("Hello")       |
	|   Closing a File       | Always close using  close()  or use  with     | Free system resources   |  python\nf.close()                                         |
	|   Using  with  block   | Automatically closes file                     | Safer and cleaner code  |  python\nwith open("file.txt") as f:\n    data = f.read()  |
		
	|   File Modes           |   Description                                 |   Example                                                  |
	| ---------------------- | --------------------------------------------- | ---------------------------------------------------------- |
	|  "r"                   | Read mode (default)                           |  python\nf = open("file.txt", "r")                         |
	|  "w"                   | Write mode (overwrites existing content)      |  python\nf = open("file.txt", "w")                         |
	|  "a"                   | Append mode (adds to end of file)             |  python\nf = open("file.txt", "a")                         |
	|  "b"                   | Binary mode (for non-text files)              |  python\nf = open("image.png", "rb")                       |
	|  "x"                   | Exclusive creation (fails if file exists)     |  python\nf = open("newfile.txt", "x")                      |
	|  "t"                   | Text mode (default, can be omitted)           |  python\nf = open("file.txt", "rt")                        |
	|  "r+"                  | Read and write mode (file must exist)         |  python\nf = open("file.txt", "r+")                         |
	|  "w+"                  | Write and read mode (overwrites existing)     |  python\nf = open("file.txt", "w+")                         |
	|  "a+"                  | Append and read mode (creates if not exists)  |  python\nf = open("file.txt", "a+")                         |
	
	
	|   File Methods         |   Description                                 |   Example                                                  |
	| ---------------------- | --------------------------------------------- | ---------------------------------------------------------- |
	|  read(size)            | Reads up to  size  bytes                      |  python	\ncontent = f.read(10)                                |
	|  readline()            | Reads one line from the file                  |  python\nline = f.readline()                                |
	|  readlines()           | Reads all lines into a list                   |  python\nlines = f.readlines()                               |
	|  write(string)         | Writes a string to the file                   |  python\n	f.write("Hello World")                           |
	|  writelines(list)      | Writes a list of strings to the file			 |  python\nf.writelines(["Line 1\n", "Line 2\n"])             |		
	|  tell()                | Returns current file position                  |  python\npos = f.tell()                                     |
	|  seek(offset, whence)  | Moves file pointer to a new position           |  python\nf.seek(0)                                         |
	|  flush()               | Flushes the internal buffer to the file       |  python\nf.flush()                                          |
	|  truncate(size)        | Resizes the file to  size  bytes               |  python\nf.truncate(100)                                    |
	|  isfile(path)          | Checks if a file exists                        |  python\nimport os\nos.path.isfile("file.txt")              |
	|  isdir(path)           | Checks if a directory exists                   |  python\nimport os\nos.path.isdir("mydir")                   |
	|  exists(path)          | Checks if a file or directory exists          |  python\nimport os\nos.path.exists("file.txt")               |
	|  remove(path)          | Deletes a file                                 |  python\nimport os\nos.remove("file.txt")                    |
	|  rename(old, new)      | Renames a file or directory                    |  python\nimport os\nos.rename("old.txt", "new.txt")           |	
	|  mkdir(path)           | Creates a new directory                        |  python\nimport os\nos.mkdir("newdir")                         |
	|  rmdir(path)           | Removes an empty directory                     |  python\nimport os\nos.rmdir("emptydir")                         |
	|  listdir(path)         | Lists files and directories in a directory    |  python\nimport os\nfiles = os.listdir("mydir")                 |
	|  getsize(path)         | Returns the size of a file in bytes            |  python\nimport os\nsize = os.path.getsize("file.txt")          |	
	|  getmtime(path)        | Returns last modified time of a file           |  python\nimport os\nmtime = os.path.getmtime("file.txt")        |
	|  getatime(path)        | Returns last access time of a file             |  python\nimport os\natime = os.path.getatime("file.txt")        |
	|  getctime(path)        | Returns creation time of a file                |  python\nimport os\nctime = os.path.getctime("file.txt")        |
	|  copy(src, dst)        | Copies a file from  src  to  dst               |  python\nimport shutil\nshutil.copy("file.txt", "copy.txt")     |
	|  move(src, dst)        | Moves a file from  src  to  dst               |  python\nimport shutil\nshutil.move("file.txt", "newdir/")      |
	|  chmod(path, mode)     | Changes file permissions                       |  python\nimport os\nos.chmod("file.txt", 0o644)                      |
	|  chown(path, uid, gid) | Changes file owner and group                  |  python\nimport os\nos.chown("file.txt", uid, gid)                  |
	|  stat(path)            | Returns file status information               |  python\nimport os\ninfo = os.stat("file.txt")                       |	
	|  walk(top)             | Generates file names in a directory tree      |  python\nimport os\nfor dirpath, dirnames, filenames in os.walk("mydir"):\n    print(dirpath, dirnames, filenames)  |
	|  tempfile              | Module for creating temporary files          |  python\nimport tempfile\nwith tempfile.TemporaryFile() as f:\n    f.write(b"Hello")\n    f.seek(0)\n    print(f.read())  |
	|  os  Module            | Provides functions for file and directory operations |  python\nimport os\nos.listdir("mydir")                               |
	|  shutil  Module        | High-level file operations like copy, move   | |  python\nimport shutil\nshutil.copy("file.txt", "copy.txt")           |
	|  pathlib  Module       | Object-oriented file system paths           |  python\nfrom pathlib import Path\np = Path("file.txt")\nprint(p.exists())  |
	|  json  Module          | Read/write JSON files                       |  python\nimport json\nwith open("data.json", "r") as f:\n    data = json.load(f)  |
	|  csv  Module           | Read/write CSV files                        |  python\nimport csv\nwith open("data.csv", "r") as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)  |
	|  pickle  Module        | Serialize/deserialize Python objects       |  python\nimport pickle\nwith open("data.pkl", "wb") as f:\n    pickle.dump(obj, f)  |
	|  xml.etree.ElementTree | Read/write XML files                       |  python\nimport xml.etree.ElementTree as ET\n\nroot = ET.Element("root")\nchild = ET.SubElement(root, "child")\nchild.text = "Hello"\ntree = ET.ElementTree(root)\ntree.write("data.xml")  |
	|  zipfile  Module       | Read/write ZIP files                        |  python\nimport zipfile\nwith zipfile.ZipFile("archive.zip", "r") as z:\n    z.extractall("extracted")  |
	|  tarfile  Module       | Read/write TAR files                        |  python\nimport tarfile\nwith tarfile.open("archive.tar.gz", "r:gz") as tar:\n    tar.extractall("extracted")  |
	|  gzip  Module          | Read/write GZIP files                       |  python\nimport gzip\nwith gzip.open("file.gz", "rb") as f:\n    content = f.read()  |
	|  bz2  Module           | Read/write BZ2 compressed files            |  python\nimport bz2\nwith bz2.open("file.bz2", "rb") as f:\n    content = f.read()  |
	|  lzma  Module          | Read/write LZMA compressed files           |  python\nimport lzma\nwith lzma.open("file.xz", "rb") as f:\n    content = f.read()  |
	|  os.path  Module       | Path manipulation functions                |  python\nimport os.path\nprint(os.path.join("dir", "file.txt"))  |
	|  fnmatch  Module       | Filename matching using wildcards          |  python\nimport fnmatch\nprint(fnmatch.fnmatch("file.txt", "*.txt"))  |
	|  glob  Module          | Find files matching a pattern              |  python\nimport glob\nprint(glob.glob("*.txt"))  |
	|  shutil  Module        | High-level file operations like copy, move |  python\nimport shutil\nshutil.copy("file.txt", "copy.txt")  |




Collections Module:
``````````````````````
	- The  collections  module provides specialized container datatypes that extend the built-in types like  list ,  dict , and  set .
	- These data structures are optimized for specific use cases, making them more efficient and easier to use in certain scenarios.
	   python
	from collections import Counter, defaultdict, deque, namedtuple, OrderedDict, ChainMap, UserDict

	| Collection Type | Import & Example Code                                                            | Purpose / Description                                                                                   | Example Output                               |
	| --------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
	|  Counter        |  from collections import Counter <br> Counter("apple")                           | 🧮 Counts how many times each item appears in a collection                                              |  {'p': 2, 'a': 1, 'l': 1, 'e': 1}            |
	|  defaultdict    |  from collections import defaultdict <br> d = defaultdict(int) <br> d['a'] += 1  | 🔧 Like a normal  dict , but returns a   default value   when accessing missing keys                    |  {'a': 1, 'b': 0}                            |
	|  deque          |  from collections import deque <br> dq = deque([1, 2]) <br> dq.appendleft(0)     | ↔️ Double-ended queue – fast adding/removing from   both ends                                           |  deque([0, 1, 2])                            |
	|  namedtuple     |  from collections import namedtuple <br> Point = namedtuple("Point", "x y")      | 🏷 A tuple with   named fields   – acts like a lightweight class                                        |  p = Point(1, 2)  → access like  p.x ,  p.y  |
	|  OrderedDict    |  from collections import OrderedDict <br> od = OrderedDict()                     | 📋 Dictionary that remembers the   insertion order   (Note: normal  dict  does this in Python 3.7+)     |  {'a': 1, 'b': 2}                            |
	|  ChainMap       |  from collections import ChainMap <br> cm = ChainMap(dict1, dict2)               | 🔗 Combines multiple dicts into a single view – reads from first, falls back to second if key not found |  {'a': 1, 'b': 2}  (combined from 2 dicts)   |
	|  UserDict       |  from collections import UserDict <br> class MyDict(UserDict): pass             | 📖 Custom dictionary class that extends  dict  functionality                                          |  MyDict({'a': 1})                             |

	Counter: 
	| Task / Feature                   | Example Code                      | Output / Description                                                 |                                                                                    |
	| -------------------------------- | --------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
	|   1. Count elements              |  Counter("banana")                |  Counter({'a': 3, 'n': 2, 'b': 1})  – counts each character          |                                                                                    |
	|   2. Get count of a value        |  c['a']                           |  3  – returns how many times  'a'  appears                           |                                                                                    |
	|   3. Safe access (missing key)   |  c['z']                           |  0  – returns  0  if the item does not exist (no error)              |                                                                                    |
	|   4. List all items              |  c.items()                        |  dict_items([('b', 1), ('a', 3), ('n', 2)])                          |                                                                                    |
	|   5. List all keys only          |  c.keys()                         |  dict_keys(['b', 'a', 'n'])                                          |                                                                                    |
	|   6. List all counts only        |  c.values()                       |  dict_values([1, 3, 2])                                              |                                                                                    |
	|   7. Most common N items         |  c.most_common(2)                 |  [('a', 3), ('n', 2)]  – top 2 most frequent items                   |                                                                                    |
	|   8. All elements expanded       |  list(c.elements())               |  ['b', 'a', 'a', 'a', 'n', 'n']  – repeats each item by its count    |                                                                                    |
	|   9. Add two Counters            |  Counter("abc") + Counter("bcd")  |  Counter({'b': 2, 'c': 2, 'a': 1, 'd': 1})                           |                                                                                    |
	|   10. Subtract Counters          |  Counter("abc") - Counter("bcd")  |  Counter({'a': 1})  – subtracts counts, removes negatives            |                                                                                    |
	|   11. Minimum (Intersection)     |  Counter("abc") & Counter("bcd")  |  Counter({'b': 1, 'c': 1})  – keeps the lower count for common items |                                                                                    |
	|   12. Maximum (Union)            | \ Counter("abc")                  | Counter("bcd")\                                                      |  Counter({'b': 1, 'c': 1, 'a': 1, 'd': 1})  – keeps the higher count for each item |
	|   13. Update with more data      |  c.update("ana")                  | Adds counts from "ana" to the existing Counter                       |                                                                                    |
	|   14. Delete an item             |  del c['a']                       | Removes the item  'a'  entirely from the Counter                     |                                                                                    |
	|   15. Clear all counts           |  c.clear()                        | Empties the Counter, making it empty                                 |                                                                                    |
	|   16. Convert to dict            |  dict(c)                          | Converts Counter to a regular dictionary                             |                                                                                    |